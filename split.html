<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snap PDF - Split PDF File</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- PDF-Lib for PDF manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

    <!-- PDF.js for rendering PDF pages -->
    <script src="https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.min.js"></script>
    
    <!-- JSZip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX transpilation in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Custom Tailwind Config -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'snap-red': '#e53935',
              'snap-red-dark': '#c62828',
              'snap-gray': {
                100: '#f7fafc',
                200: '#edf2f7',
                300: '#e2e8f0',
                400: '#cbd5e0',
                500: '#a0aec0',
                600: '#718096',
                700: '#4a5568',
                800: '#2d3748',
                900: '#1a202c',
              },
            }
          }
        }
      }
    </script>
    <script>
      // Set worker source for PDF.js
      if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@4.4.168/build/pdf.worker.min.mjs';
      }
    </script>
</head>
<body class="bg-snap-gray-100 font-sans">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useCallback, useRef, useEffect, Fragment } = React;

      // --- ICONS ---
      const CheckIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" />
        </svg>
      );


      // --- GENERIC COMPONENTS ---
      const Header = ({ onHomeClick }) => {
        return (
          <header className="bg-white shadow-md w-full sticky top-0 z-50">
            <nav className="container mx-auto px-4 sm:px-6 lg:px-8">
              <div className="flex items-center justify-center md:justify-start h-16">
                <a onClick={(e) => { e.preventDefault(); onHomeClick(); }} href="#" className="flex-shrink-0 flex items-center gap-2 cursor-pointer">
                  <svg className="w-8 h-8 text-snap-red" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path fillRule="evenodd" clipRule="evenodd" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM9.5 16.5L5 12l1.41-1.41L9.5 13.67l7.09-7.09L18 8l-8.5 8.5z" />
                  </svg>
                  <span className="text-2xl font-bold text-snap-gray-800">Snap PDF</span>
                </a>
              </div>
            </nav>
          </header>
        );
      };

      const ProcessingScreen = ({ text }) => {
        return (
          <div className="flex flex-col items-center justify-center text-center p-8">
            <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-snap-red mb-6"></div>
            <h2 className="text-2xl md:text-3xl font-bold text-snap-gray-800">{text.title}</h2>
            <p className="text-lg text-snap-gray-600 mt-2">{text.subtitle}</p>
          </div>
        );
      };

      const DownloadScreen = ({ downloadUrl, downloadFilename, title, subtitle, onStartOver, startOverText }) => {
        return (
          <div className="text-center p-8">
            <svg className="w-16 h-16 text-green-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <h2 className="text-3xl md:text-4xl font-bold text-snap-gray-800">{title}</h2>
            <p className="text-lg text-snap-gray-600 mt-2 mb-8">{subtitle}</p>
            
            <a
              href={downloadUrl}
              download={downloadFilename}
              className="inline-block bg-snap-red text-white text-xl font-bold px-12 py-6 rounded-lg shadow-lg hover:bg-snap-red-dark transition-transform transform hover:scale-105"
            >
              Download file
            </a>
            
            <div className="mt-12">
              <button onClick={onStartOver} className="text-snap-gray-600 hover:text-snap-red font-semibold transition-colors">
                {startOverText}
              </button>
            </div>
          </div>
        );
      };
      
      
      // --- SPLIT TOOL ---
      const SplitTool = () => {
        const [status, setStatus] = useState('uploading');
        const [file, setFile] = useState(null);
        const [pdfDoc, setPdfDoc] = useState(null);
        const [pages, setPages] = useState([]);
        const [splitMode, setSplitMode] = useState('extract'); // 'extract' or 'range'
        const [extractMode, setExtractMode] = useState('all'); // 'all' or 'select'
        const [ranges, setRanges] = useState([{ from: '', to: '' }]);
        const [mergeOutput, setMergeOutput] = useState(false);
        const [downloadData, setDownloadData] = useState(null);
        const [error, setError] = useState(null);

        useEffect(() => {
          return () => {
            if (downloadData?.url) {
              URL.revokeObjectURL(downloadData.url);
            }
          };
        }, [downloadData]);

        const loadPdf = async (selectedFile) => {
          try {
            const arrayBuffer = await selectedFile.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const doc = await loadingTask.promise;
            setPdfDoc(doc);
            const pageData = Array.from({ length: doc.numPages }, (_, i) => ({
              pageNum: i + 1,
              selected: extractMode === 'all',
            }));
            setPages(pageData);
            setStatus('editing');
          } catch (e) {
            console.error(e);
            setError('Could not load PDF. The file might be corrupted or password-protected.');
            setStatus('uploading');
          }
        };

        const handleFileSelected = (selectedFiles) => {
          const pdfFile = Array.from(selectedFiles).find(f => f.type === 'application/pdf');
          if (pdfFile) {
            setFile(pdfFile);
            setError(null);
            loadPdf(pdfFile);
          }
        };
        
        const handleStartOver = () => {
          setStatus('uploading');
          setFile(null);
          setPdfDoc(null);
          setPages([]);
          setRanges([{ from: '', to: '' }]);
          setMergeOutput(false);
          if (downloadData?.url) URL.revokeObjectURL(downloadData.url);
          setDownloadData(null);
          setError(null);
        };
        
        const handleSplit = async () => {
            setStatus('splitting');
            setError(null);

            try {
                const { PDFDocument } = window.PDFLib;
                const arrayBuffer = await file.arrayBuffer();
                const sourcePdf = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

                const outputDocs = [];

                if (splitMode === 'extract') {
                    const selectedPages = pages.filter(p => p.selected).map(p => p.pageNum - 1);
                    if (selectedPages.length === 0) {
                        setError('Please select at least one page to extract.');
                        setStatus('editing');
                        return;
                    }

                    if (mergeOutput) {
                        const newPdf = await PDFDocument.create();
                        const copiedPages = await newPdf.copyPages(sourcePdf, selectedPages);
                        copiedPages.forEach(page => newPdf.addPage(page));
                        outputDocs.push({ doc: newPdf, name: `${file.name.replace('.pdf', '')}_extracted.pdf` });
                    } else {
                        for (const pageIndex of selectedPages) {
                            const newPdf = await PDFDocument.create();
                            const [copiedPage] = await newPdf.copyPages(sourcePdf, [pageIndex]);
                            newPdf.addPage(copiedPage);
                            outputDocs.push({ doc: newPdf, name: `${file.name.replace('.pdf', '')}_page_${pageIndex + 1}.pdf` });
                        }
                    }
                } else { // range mode
                    const validRanges = ranges.filter(r => r.from && r.to && r.from > 0 && r.to <= sourcePdf.getPageCount() && r.from <= r.to);
                    if (validRanges.length === 0) {
                        setError('Please define at least one valid page range.');
                        setStatus('editing');
                        return;
                    }

                    if (mergeOutput) {
                        const newPdf = await PDFDocument.create();
                        for (const range of validRanges) {
                            const pageIndices = [];
                            for (let i = range.from; i <= range.to; i++) {
                                pageIndices.push(i - 1);
                            }
                            const copiedPages = await newPdf.copyPages(sourcePdf, pageIndices);
                            copiedPages.forEach(page => newPdf.addPage(page));
                        }
                        outputDocs.push({ doc: newPdf, name: `${file.name.replace('.pdf', '')}_ranged.pdf` });
                    } else {
                        for (const [i, range] of validRanges.entries()) {
                            const newPdf = await PDFDocument.create();
                            const pageIndices = [];
                            for (let p = range.from; p <= range.to; p++) {
                                pageIndices.push(p - 1);
                            }
                            const copiedPages = await newPdf.copyPages(sourcePdf, pageIndices);
                            copiedPages.forEach(page => newPdf.addPage(page));
                            outputDocs.push({ doc: newPdf, name: `${file.name.replace('.pdf', '')}_range_${range.from}-${range.to}.pdf` });
                        }
                    }
                }

                if (outputDocs.length === 0) {
                  setError('No pages were selected for splitting.');
                  setStatus('editing');
                  return;
                }

                if (outputDocs.length === 1) {
                    const pdfBytes = await outputDocs[0].doc.save();
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    setDownloadData({ url, name: outputDocs[0].name, isZip: false });
                } else {
                    const zip = new JSZip();
                    for (const { doc, name } of outputDocs) {
                        const pdfBytes = await doc.save();
                        zip.file(name, pdfBytes);
                    }
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(zipBlob);
                    setDownloadData({ url, name: 'snap-pdf_split.zip', isZip: true });
                }
                setStatus('finished');
            } catch (e) {
                console.error(e);
                setError('An error occurred while splitting the PDF. The file may be invalid or encrypted.');
                setStatus('editing');
            }
        };


        const UploadScreen = ({ onFilesSelected }) => {
            const [isDragging, setIsDragging] = useState(false);
            const handleFileChange = (e) => { e.target.files?.length && onFilesSelected(e.target.files); };
            const handleDrop = useCallback((e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); e.dataTransfer.files?.length && onFilesSelected(e.dataTransfer.files); }, [onFilesSelected]);
            const handleDragOver = useCallback((e) => { e.preventDefault(); e.stopPropagation(); }, []);
            const handleDragEnter = useCallback((e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); }, []);
            const handleDragLeave = useCallback((e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); }, []);

            return (
              <div 
                className={`w-full max-w-4xl text-center p-8 transition-all duration-300 ${isDragging ? 'bg-red-50' : ''}`}
                onDrop={handleDrop} onDragOver={handleDragOver} onDragEnter={handleDragEnter} onDragLeave={handleDragLeave}
              >
                <h1 className="text-3xl md:text-4xl font-bold text-snap-gray-800">Split PDF file</h1>
                <p className="text-lg text-snap-gray-600 mt-2 mb-8">Separate one page or a whole set for easy conversion into independent PDF files.</p>
                <div className="relative inline-block">
                  <input type="file" id="file-upload" accept=".pdf" className="absolute inset-0 w-full h-full opacity-0 cursor-pointer" onChange={handleFileChange} />
                  <label htmlFor="file-upload" className="flex items-center justify-center bg-snap-red text-white text-xl font-bold px-12 py-6 rounded-lg shadow-lg cursor-pointer hover:bg-snap-red-dark transition-transform transform hover:scale-105">
                    Select PDF file
                  </label>
                </div>
                <p className="mt-6 text-snap-gray-500">or drop PDF here</p>
              </div>
            );
        };
        
        const PdfPagePreview = ({ pdfDoc, pageNum, onSelect, isSelected }) => {
          const canvasRef = useRef(null);
          useEffect(() => {
            const render = async () => {
              const page = await pdfDoc.getPage(pageNum);
              const viewport = page.getViewport({ scale: 0.3 });
              const canvas = canvasRef.current;
              if (!canvas) return;
              const context = canvas.getContext('2d');
              canvas.height = viewport.height;
              canvas.width = viewport.width;
              await page.render({ canvasContext: context, viewport }).promise;
            };
            if (pdfDoc) render();
          }, [pdfDoc, pageNum]);

          return (
            <div onClick={onSelect} className={`relative border-2 rounded-lg p-1 cursor-pointer transition-all ${isSelected ? 'border-snap-red' : 'border-gray-200 hover:border-snap-red'}`}>
              <canvas ref={canvasRef} className="rounded-md"></canvas>
              <div className="absolute bottom-1 right-1 bg-black bg-opacity-60 text-white text-xs rounded-sm px-1.5 py-0.5">{pageNum}</div>
              {isSelected && (
                <div className="absolute top-1 right-1 bg-snap-red rounded-full w-6 h-6 flex items-center justify-center">
                  <CheckIcon />
                </div>
              )}
            </div>
          );
        };

        const OptionsPanel = () => {
          useEffect(() => {
            setPages(prev => prev.map(p => ({...p, selected: extractMode === 'all' })));
          }, [extractMode]);

          const handleRangeChange = (index, field, value) => {
            const newRanges = [...ranges];
            const numValue = parseInt(value, 10);
            newRanges[index][field] = isNaN(numValue) ? '' : numValue;
            setRanges(newRanges);
          };

          const addRange = () => setRanges([...ranges, { from: '', to: '' }]);
          const removeRange = (index) => setRanges(ranges.filter((_, i) => i !== index));

          const selectedCount = pages.filter(p => p.selected).length;

          return (
            <div className="bg-white p-6 rounded-lg shadow-lg sticky top-24">
              <h2 className="text-xl font-bold text-snap-gray-800 mb-4">Split options</h2>
              
              <div className="flex border border-gray-200 rounded-lg mb-4">
                  <button onClick={() => setSplitMode('extract')} className={`flex-1 p-2 font-semibold text-center ${splitMode === 'extract' ? 'bg-snap-red text-white rounded-l-md' : 'hover:bg-gray-100'}`}>Extract pages</button>
                  <button onClick={() => setSplitMode('range')} className={`flex-1 p-2 font-semibold text-center ${splitMode === 'range' ? 'bg-snap-red text-white rounded-r-md' : 'hover:bg-gray-100'}`}>Split by range</button>
              </div>

              {splitMode === 'extract' ? (
                <div className="space-y-4">
                  <p className="text-sm text-snap-gray-600">Click on pages to select them. Click again to deselect.</p>
                  <div className="flex items-center space-x-4">
                    <button onClick={() => setExtractMode('all')} className={`text-sm py-1 px-3 rounded-full ${extractMode === 'all' ? 'bg-snap-red text-white' : 'bg-gray-200'}`}>Extract all</button>
                    <button onClick={() => setExtractMode('select')} className={`text-sm py-1 px-3 rounded-full ${extractMode === 'select' ? 'bg-snap-red text-white' : 'bg-gray-200'}`}>Select pages</button>
                  </div>
                   <div className="flex items-center">
                    <input id="merge-extract" type="checkbox" checked={mergeOutput} onChange={(e) => setMergeOutput(e.target.checked)} className="h-4 w-4 text-snap-red border-gray-300 rounded focus:ring-snap-red"/>
                    <label htmlFor="merge-extract" className="ml-2 block text-sm text-gray-900">Merge extracted pages into one PDF.</label>
                  </div>
                  <div className="text-sm bg-snap-gray-100 p-2 rounded-md">
                    {selectedCount} of {pages.length} pages selected.
                  </div>
                </div>
              ) : (
                <div className="space-y-4">
                  <p className="text-sm text-snap-gray-600">Define ranges to split the PDF. Each range can be saved as a separate file.</p>
                   {ranges.map((range, index) => (
                      <div key={index} className="flex items-center gap-2">
                        <span className="text-sm">Range {index+1}:</span>
                        <input type="number" placeholder="from" value={range.from} onChange={(e) => handleRangeChange(index, 'from', e.target.value)} className="w-16 p-1 border rounded-md text-sm" min="1" max={pages.length} />
                        <span className="text-sm">-</span>
                        <input type="number" placeholder="to" value={range.to} onChange={(e) => handleRangeChange(index, 'to', e.target.value)} className="w-16 p-1 border rounded-md text-sm" min="1" max={pages.length} />
                        <button onClick={() => removeRange(index)} className="text-red-500 hover:text-red-700">&times;</button>
                      </div>
                    ))}
                  <button onClick={addRange} className="text-sm text-snap-red font-semibold">+ Add range</button>
                   <div className="flex items-center pt-2">
                    <input id="merge-range" type="checkbox" checked={mergeOutput} onChange={(e) => setMergeOutput(e.target.checked)} className="h-4 w-4 text-snap-red border-gray-300 rounded focus:ring-snap-red"/>
                    <label htmlFor="merge-range" className="ml-2 block text-sm text-gray-900">Merge all ranges into one PDF.</label>
                  </div>
                </div>
              )}
              
              <button onClick={handleSplit} className="mt-6 w-full bg-snap-red hover:bg-snap-red-dark text-white font-bold py-4 px-4 rounded-lg text-lg transition-transform transform hover:scale-105">
                Split PDF
              </button>
            </div>
          );
        };
        
        if (status === 'uploading') return <UploadScreen onFilesSelected={handleFileSelected} />;
        if (status === 'splitting') return <ProcessingScreen text={{ title: "Splitting PDF...", subtitle: "Please wait while we process your file."}} />;
        if (status === 'finished' && downloadData) return (
             <DownloadScreen 
              downloadUrl={downloadData.url} 
              downloadFilename={downloadData.name}
              title="PDF has been split!"
              subtitle="Your file has been successfully processed."
              onStartOver={handleStartOver} 
              startOverText="Split another PDF"
            />
        );

        return (
          <div className="w-full max-w-6xl flex flex-col md:flex-row gap-8">
            <div className="flex-grow bg-white p-4 sm:p-6 rounded-lg shadow-lg">
              {error && <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">{error}</div>}
              <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-7 gap-4">
                {pages.map(({pageNum, selected}) => (
                  <PdfPagePreview 
                    key={pageNum}
                    pdfDoc={pdfDoc}
                    pageNum={pageNum}
                    isSelected={selected}
                    onSelect={() => {
                      if (extractMode === 'select' && splitMode === 'extract') {
                        setPages(prev => prev.map(p => p.pageNum === pageNum ? {...p, selected: !p.selected} : p));
                      }
                    }}
                  />
                ))}
              </div>
            </div>
            <aside className="w-full md:w-72 lg:w-80 flex-shrink-0">
                <OptionsPanel />
            </aside>
          </div>
        );
      };


      // --- MAIN APP ---
      const App = () => {
        const [resetKey, setResetKey] = useState(0);

        const handleHomeClick = () => {
            setResetKey(prevKey => prevKey + 1);
        };

        return (
          <div className="flex flex-col min-h-screen">
            <Header onHomeClick={handleHomeClick} />
            <main className="flex-grow flex items-center justify-center p-4 md:p-8">
                <SplitTool key={resetKey} />
            </main>
          </div>
        );
      };

      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(<App />);
    </script>
</body>
</html>
