<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snap PDF - Split PDF Files</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- pdf-lib for client-side PDF manipulation -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <!-- jszip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gray-50">
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useRef, useCallback, useEffect } = React;

      // --- React Components ---

      const Header = () => (
        <header className="bg-white shadow-sm w-full py-4 px-6 sticky top-0 z-30">
          <div className="container mx-auto">
            <h1 className="text-2xl font-bold text-red-600">Snap PDF</h1>
          </div>
        </header>
      );
      
      const FileIcon = () => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 text-red-500" viewBox="0 0 20 20" fill="currentColor">
          <path fillRule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clipRule="evenodd" />
        </svg>
      );

      const FileDropzone = ({ onFileAdded }) => {
        const [isDragging, setIsDragging] = useState(false);
        const fileInputRef = useRef(null);

        const handleDragOver = (e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsDragging(true);
        };

        const handleDragLeave = (e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsDragging(false);
        };

        const handleDrop = (e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsDragging(false);
          if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            onFileAdded(e.dataTransfer.files[0]);
          }
        };

        const handleFileChange = (e) => {
          if (e.target.files && e.target.files.length > 0) {
            onFileAdded(e.target.files[0]);
          }
        };

        const onButtonClick = () => {
          fileInputRef.current?.click();
        };

        return (
          <div
            className={`flex flex-col items-center justify-center text-center p-8 border-4 border-dashed rounded-xl transition-colors duration-300 ${isDragging ? 'border-red-500 bg-red-50' : 'border-gray-300 bg-white'}`}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <h2 className="text-4xl font-extrabold mb-2 text-gray-800">Split PDF file</h2>
            <p className="text-gray-500 mb-8 max-w-md">Separate one page or a whole set for easy conversion into independent PDF files.</p>
            
            <input
              ref={fileInputRef}
              type="file"
              accept="application/pdf"
              className="hidden"
              onChange={handleFileChange}
            />
            <button
              onClick={onButtonClick}
              className="bg-red-600 text-white font-bold py-4 px-8 rounded-lg text-xl shadow-lg hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300"
            >
              Select PDF file
            </button>
            <p className="mt-4 text-gray-500">or drop PDF here</p>
          </div>
        );
      };

      const App = () => {
        const [pdfFile, setPdfFile] = useState(null);
        const [pageCount, setPageCount] = useState(0);
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);
        const [splitMode, setSplitMode] = useState('range'); // 'range' or 'extract'
        
        // State for 'range' mode
        const [ranges, setRanges] = useState([{ id: 1, from: '1', to: '1' }]);
        const [mergeRanges, setMergeRanges] = useState(false);

        // State for 'extract' mode
        const [extractPagesText, setExtractPagesText] = useState('');
        const [mergeExtracted, setMergeExtracted] = useState(false);

        const { PDFDocument } = window.PDFLib;

        const handleFileAdded = useCallback(async (file) => {
          if (file.type !== 'application/pdf') {
            setError("Please select a valid PDF file.");
            return;
          }
          setError(null);
          setIsLoading(true);
          try {
            const arrayBuffer = await file.arrayBuffer();
            const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });
            const count = pdfDoc.getPageCount();
            setPageCount(count);
            setPdfFile(file);
            setRanges([{ id: 1, from: '1', to: count > 0 ? String(count) : '1' }]);
            setExtractPagesText(`1-${count > 0 ? count : 1}`);
          } catch (e) {
            console.error(e);
            setError("Could not read the PDF file. It might be corrupted or password-protected.");
            setPdfFile(null);
            setPageCount(0);
          } finally {
            setIsLoading(false);
          }
        }, []);

        const parsePageSelection = (text, max) => {
            const pages = new Set();
            if (!text) return [];
            const parts = text.split(',');
            for (const part of parts) {
                if (part.includes('-')) {
                    const [start, end] = part.split('-').map(p => parseInt(p.trim(), 10));
                    if (!isNaN(start) && !isNaN(end) && start <= end && start > 0 && end <= max) {
                        for (let i = start; i <= end; i++) {
                            pages.add(i);
                        }
                    } else {
                      throw new Error(`Invalid range: "${part}". Pages must be between 1 and ${max}.`);
                    }
                } else {
                    const page = parseInt(part.trim(), 10);
                    if (!isNaN(page) && page > 0 && page <= max) {
                        pages.add(page);
                    } else {
                       throw new Error(`Invalid page number: "${part}". Pages must be between 1 and ${max}.`);
                    }
                }
            }
            return Array.from(pages).sort((a, b) => a - b);
        };


        const handleSplit = async () => {
            if (!pdfFile) return;

            setIsLoading(true);
            setError(null);

            try {
                const originalPdfBytes = await pdfFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(originalPdfBytes, { ignoreEncryption: true });

                if (splitMode === 'range') {
                    const validRanges = ranges.filter(r => 
                        parseInt(r.from, 10) > 0 && 
                        parseInt(r.to, 10) <= pageCount && 
                        parseInt(r.from, 10) <= parseInt(r.to, 10)
                    );
                    if (validRanges.length === 0) throw new Error("No valid ranges to split.");

                    if (mergeRanges) {
                        const newPdf = await PDFDocument.create();
                        let pagesToCopyIndices = [];
                        for (const range of validRanges) {
                            for (let i = parseInt(range.from, 10); i <= parseInt(range.to, 10); i++) {
                                pagesToCopyIndices.push(i - 1);
                            }
                        }
                        // Remove duplicates and sort
                        pagesToCopyIndices = [...new Set(pagesToCopyIndices)].sort((a,b) => a - b);
                        
                        const copiedPages = await newPdf.copyPages(pdfDoc, pagesToCopyIndices);
                        copiedPages.forEach(page => newPdf.addPage(page));
                        
                        const pdfBytes = await newPdf.save();
                        downloadBlob(pdfBytes, `${pdfFile.name.replace('.pdf', '')}_merged_ranges.pdf`, 'application/pdf');

                    } else {
                        const zip = new window.JSZip();
                        for (let i = 0; i < validRanges.length; i++) {
                            const range = validRanges[i];
                            const newPdf = await PDFDocument.create();
                            const pageIndices = [];
                            for (let j = parseInt(range.from, 10); j <= parseInt(range.to, 10); j++) {
                                pageIndices.push(j - 1);
                            }
                            const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                            copiedPages.forEach(page => newPdf.addPage(page));
                            const pdfBytes = await newPdf.save();
                            zip.file(`${pdfFile.name.replace('.pdf', '')}_range_${range.from}-${range.to}.pdf`, pdfBytes);
                        }
                        const zipBlob = await zip.generateAsync({ type: "blob" });
                        downloadBlob(zipBlob, 'snap_pdf_split_ranges.zip', 'application/zip');
                    }
                } else if (splitMode === 'extract') {
                    const pagesToExtract = parsePageSelection(extractPagesText, pageCount);
                    if (pagesToExtract.length === 0) throw new Error("No valid pages selected for extraction.");
                    const pageIndices = pagesToExtract.map(p => p - 1);

                    if (mergeExtracted) {
                        const newPdf = await PDFDocument.create();
                        const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);
                        copiedPages.forEach(page => newPdf.addPage(page));
                        const pdfBytes = await newPdf.save();
                        downloadBlob(pdfBytes, `${pdfFile.name.replace('.pdf', '')}_extracted.pdf`, 'application/pdf');
                    } else {
                        const zip = new window.JSZip();
                        for (const pageIndex of pageIndices) {
                            const newPdf = await PDFDocument.create();
                            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageIndex]);
                            newPdf.addPage(copiedPage);
                            const pdfBytes = await newPdf.save();
                            zip.file(`${pdfFile.name.replace('.pdf', '')}_page_${pageIndex + 1}.pdf`, pdfBytes);
                        }
                        const zipBlob = await zip.generateAsync({ type: "blob" });
                        downloadBlob(zipBlob, 'snap_pdf_extracted_pages.zip', 'application/zip');
                    }
                }
                
                // Reset after successful split
                setPdfFile(null);
                setPageCount(0);

            } catch (e) {
                console.error(e);
                setError(e.message || "An error occurred during the splitting process. Please check your page ranges and try again.");
            } finally {
                setIsLoading(false);
            }
        };

        const downloadBlob = (data, fileName, mimeType) => {
            const blob = new Blob([data], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        };

        const handleAddRange = () => setRanges([...ranges, { id: Date.now(), from: '', to: '' }]);
        const handleRemoveRange = (id) => setRanges(ranges.filter(r => r.id !== id));
        const handleRangeChange = (id, field, value) => {
            setRanges(ranges.map(r => r.id === id ? { ...r, [field]: value } : r));
        };

        return (
          <div className="flex flex-col min-h-screen bg-gray-50 font-sans">
            <Header />
            <main className="flex-grow container mx-auto p-4 md:p-8 flex flex-col items-center">
              {!pdfFile ? (
                <div className="w-full max-w-4xl mt-10">
                  {isLoading ? (
                     <div className="text-center">
                        <p className="text-xl text-gray-700">Reading your PDF...</p>
                      </div>
                  ) : (
                    <FileDropzone onFileAdded={handleFileAdded} />
                  )}
                  {error && <p className="text-red-600 mt-4 text-center">{error}</p>}
                </div>
              ) : (
                <div className="w-full flex flex-col lg:flex-row gap-8">
                  {/* Left Column: File Preview */}
                  <div className="w-full lg:w-1/3">
                    <h3 className="text-xl font-bold text-gray-800 mb-4">Your File</h3>
                    <div className="bg-white border rounded-lg p-4 flex flex-col items-center text-center shadow-sm relative">
                       <button
                          onClick={() => { setPdfFile(null); setPageCount(0); setError(null); }}
                          className="absolute top-2 right-2 bg-gray-700 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600 z-10"
                          aria-label={`Remove ${pdfFile.name}`}
                        >
                          <span className="text-lg leading-none">&times;</span>
                        </button>
                      <FileIcon />
                      <p className="mt-2 text-sm font-medium text-gray-700 break-words w-full px-2">{pdfFile.name}</p>
                      <p className="text-xs text-gray-500 mt-1">{pageCount} pages</p>
                    </div>
                  </div>
                  
                  {/* Right Column: Split Options */}
                  <div className="w-full lg:w-2/3 bg-white p-6 rounded-lg shadow-sm border">
                    <div className="flex border-b mb-4">
                        <button onClick={() => setSplitMode('range')} className={`py-2 px-4 font-semibold ${splitMode === 'range' ? 'text-red-600 border-b-2 border-red-600' : 'text-gray-500'}`}>Split by range</button>
                        <button onClick={() => setSplitMode('extract')} className={`py-2 px-4 font-semibold ${splitMode === 'extract' ? 'text-red-600 border-b-2 border-red-600' : 'text-gray-500'}`}>Extract pages</button>
                    </div>

                    {/* Split by Range Options */}
                    {splitMode === 'range' && (
                        <div>
                            <p className="text-gray-600 text-sm mb-4">Define ranges to create separate PDF files. Add more ranges as needed.</p>
                            {ranges.map((range, index) => (
                                <div key={range.id} className="flex items-center gap-2 mb-3 bg-gray-50 p-3 rounded-md">
                                    <span className="font-semibold text-gray-500">Range {index + 1}</span>
                                    <input type="number" placeholder="From" min="1" max={pageCount} value={range.from} onChange={(e) => handleRangeChange(range.id, 'from', e.target.value)} className="w-24 p-2 border rounded-md" />
                                    <span className="text-gray-500">-</span>
                                    <input type="number" placeholder="To" min="1" max={pageCount} value={range.to} onChange={(e) => handleRangeChange(range.id, 'to', e.target.value)} className="w-24 p-2 border rounded-md" />
                                    {ranges.length > 1 && <button onClick={() => handleRemoveRange(range.id)} className="text-red-500 hover:text-red-700 p-2">&times;</button>}
                                </div>
                            ))}
                            <button onClick={handleAddRange} className="text-red-600 font-semibold text-sm mt-2">+ Add range</button>
                             <div className="mt-6 border-t pt-4">
                                <label className="flex items-center">
                                    <input type="checkbox" checked={mergeRanges} onChange={(e) => setMergeRanges(e.target.checked)} className="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500" />
                                    <span className="ml-2 text-gray-700">Merge all ranges in one PDF file</span>
                                </label>
                            </div>
                        </div>
                    )}

                    {/* Extract Pages Options */}
                    {splitMode === 'extract' && (
                       <div>
                            <p className="text-gray-600 text-sm mb-4">Select pages to extract. Use commas to separate pages or dashes for ranges (e.g., 1, 3, 5-8).</p>
                            <input type="text" value={extractPagesText} onChange={(e) => setExtractPagesText(e.target.value)} placeholder={`e.g., 1, 3, 5-${pageCount}`} className="w-full p-2 border rounded-md mb-4"/>
                            <div className="mt-6 border-t pt-4">
                                <label className="flex items-center">
                                    <input type="checkbox" checked={mergeExtracted} onChange={(e) => setMergeExtracted(e.target.checked)} className="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500" />
                                    <span className="ml-2 text-gray-700">Merge extracted pages into one PDF file</span>
                                </label>
                            </div>
                       </div>
                    )}
                    
                  </div>
                </div>
              )}
             {pdfFile && (
                <div className="fixed bottom-0 left-0 right-0 bg-white p-4 border-t z-20 shadow-[0_-2px_10px_rgba(0,0,0,0.1)]">
                    <div className="container mx-auto flex flex-col items-center justify-center">
                       {error && <p className="text-red-600 mb-4 text-center">{error}</p>}
                      <button
                        onClick={handleSplit}
                        disabled={isLoading}
                        className="bg-red-600 text-white font-bold py-4 px-16 rounded-lg text-xl shadow-lg hover:bg-red-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-300 disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none"
                      >
                        {isLoading ? 'Splitting...' : `Split PDF`}
                      </button>
                    </div>
                </div>
              )}
            </main>
          </div>
        );
      };

      // --- Application Entry Point ---
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
